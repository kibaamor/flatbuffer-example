// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PROTO_PROTOS_H_
#define FLATBUFFERS_GENERATED_PROTO_PROTOS_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

namespace Protos {

struct TextMessage;
struct TextMessageBuilder;

struct ImageMessage;
struct ImageMessageBuilder;

struct MessageRoot;
struct MessageRootBuilder;

enum class MessageContent : uint8_t {
  NONE = 0,
  TextMessage = 1,
  ImageMessage = 2,
  MIN = NONE,
  MAX = ImageMessage
};

inline const MessageContent (&EnumValuesMessageContent())[3] {
  static const MessageContent values[] = {
    MessageContent::NONE,
    MessageContent::TextMessage,
    MessageContent::ImageMessage
  };
  return values;
}

inline const char * const *EnumNamesMessageContent() {
  static const char * const names[4] = {
    "NONE",
    "TextMessage",
    "ImageMessage",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessageContent(MessageContent e) {
  if (::flatbuffers::IsOutRange(e, MessageContent::NONE, MessageContent::ImageMessage)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMessageContent()[index];
}

template<typename T> struct MessageContentTraits {
  static const MessageContent enum_value = MessageContent::NONE;
};

template<> struct MessageContentTraits<Protos::TextMessage> {
  static const MessageContent enum_value = MessageContent::TextMessage;
};

template<> struct MessageContentTraits<Protos::ImageMessage> {
  static const MessageContent enum_value = MessageContent::ImageMessage;
};

bool VerifyMessageContent(::flatbuffers::Verifier &verifier, const void *obj, MessageContent type);
bool VerifyMessageContentVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<MessageContent> *types);

struct TextMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TextMessageBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEXT = 4
  };
  const ::flatbuffers::String *text() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TEXT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           verifier.EndTable();
  }
};

struct TextMessageBuilder {
  typedef TextMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_text(::flatbuffers::Offset<::flatbuffers::String> text) {
    fbb_.AddOffset(TextMessage::VT_TEXT, text);
  }
  explicit TextMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TextMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TextMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TextMessage> CreateTextMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> text = 0) {
  TextMessageBuilder builder_(_fbb);
  builder_.add_text(text);
  return builder_.Finish();
}

struct TextMessage::Traits {
  using type = TextMessage;
  static auto constexpr Create = CreateTextMessage;
};

inline ::flatbuffers::Offset<TextMessage> CreateTextMessageDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *text = nullptr) {
  auto text__ = text ? _fbb.CreateString(text) : 0;
  return Protos::CreateTextMessage(
      _fbb,
      text__);
}

struct ImageMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ImageMessageBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_URL = 4,
    VT_WIDTH = 6,
    VT_HEIGHT = 8
  };
  const ::flatbuffers::String *url() const {
    return GetPointer<const ::flatbuffers::String *>(VT_URL);
  }
  int32_t width() const {
    return GetField<int32_t>(VT_WIDTH, 0);
  }
  int32_t height() const {
    return GetField<int32_t>(VT_HEIGHT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_URL) &&
           verifier.VerifyString(url()) &&
           VerifyField<int32_t>(verifier, VT_WIDTH, 4) &&
           VerifyField<int32_t>(verifier, VT_HEIGHT, 4) &&
           verifier.EndTable();
  }
};

struct ImageMessageBuilder {
  typedef ImageMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_url(::flatbuffers::Offset<::flatbuffers::String> url) {
    fbb_.AddOffset(ImageMessage::VT_URL, url);
  }
  void add_width(int32_t width) {
    fbb_.AddElement<int32_t>(ImageMessage::VT_WIDTH, width, 0);
  }
  void add_height(int32_t height) {
    fbb_.AddElement<int32_t>(ImageMessage::VT_HEIGHT, height, 0);
  }
  explicit ImageMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ImageMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ImageMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ImageMessage> CreateImageMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> url = 0,
    int32_t width = 0,
    int32_t height = 0) {
  ImageMessageBuilder builder_(_fbb);
  builder_.add_height(height);
  builder_.add_width(width);
  builder_.add_url(url);
  return builder_.Finish();
}

struct ImageMessage::Traits {
  using type = ImageMessage;
  static auto constexpr Create = CreateImageMessage;
};

inline ::flatbuffers::Offset<ImageMessage> CreateImageMessageDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *url = nullptr,
    int32_t width = 0,
    int32_t height = 0) {
  auto url__ = url ? _fbb.CreateString(url) : 0;
  return Protos::CreateImageMessage(
      _fbb,
      url__,
      width,
      height);
}

struct MessageRoot FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MessageRootBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME = 4,
    VT_CONTENT_TYPE = 6,
    VT_CONTENT = 8
  };
  uint64_t time() const {
    return GetField<uint64_t>(VT_TIME, 0);
  }
  Protos::MessageContent content_type() const {
    return static_cast<Protos::MessageContent>(GetField<uint8_t>(VT_CONTENT_TYPE, 0));
  }
  const void *content() const {
    return GetPointer<const void *>(VT_CONTENT);
  }
  template<typename T> const T *content_as() const;
  const Protos::TextMessage *content_as_TextMessage() const {
    return content_type() == Protos::MessageContent::TextMessage ? static_cast<const Protos::TextMessage *>(content()) : nullptr;
  }
  const Protos::ImageMessage *content_as_ImageMessage() const {
    return content_type() == Protos::MessageContent::ImageMessage ? static_cast<const Protos::ImageMessage *>(content()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_TIME, 8) &&
           VerifyField<uint8_t>(verifier, VT_CONTENT_TYPE, 1) &&
           VerifyOffset(verifier, VT_CONTENT) &&
           VerifyMessageContent(verifier, content(), content_type()) &&
           verifier.EndTable();
  }
};

template<> inline const Protos::TextMessage *MessageRoot::content_as<Protos::TextMessage>() const {
  return content_as_TextMessage();
}

template<> inline const Protos::ImageMessage *MessageRoot::content_as<Protos::ImageMessage>() const {
  return content_as_ImageMessage();
}

struct MessageRootBuilder {
  typedef MessageRoot Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_time(uint64_t time) {
    fbb_.AddElement<uint64_t>(MessageRoot::VT_TIME, time, 0);
  }
  void add_content_type(Protos::MessageContent content_type) {
    fbb_.AddElement<uint8_t>(MessageRoot::VT_CONTENT_TYPE, static_cast<uint8_t>(content_type), 0);
  }
  void add_content(::flatbuffers::Offset<void> content) {
    fbb_.AddOffset(MessageRoot::VT_CONTENT, content);
  }
  explicit MessageRootBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MessageRoot> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MessageRoot>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MessageRoot> CreateMessageRoot(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t time = 0,
    Protos::MessageContent content_type = Protos::MessageContent::NONE,
    ::flatbuffers::Offset<void> content = 0) {
  MessageRootBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_content(content);
  builder_.add_content_type(content_type);
  return builder_.Finish();
}

struct MessageRoot::Traits {
  using type = MessageRoot;
  static auto constexpr Create = CreateMessageRoot;
};

inline bool VerifyMessageContent(::flatbuffers::Verifier &verifier, const void *obj, MessageContent type) {
  switch (type) {
    case MessageContent::NONE: {
      return true;
    }
    case MessageContent::TextMessage: {
      auto ptr = reinterpret_cast<const Protos::TextMessage *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageContent::ImageMessage: {
      auto ptr = reinterpret_cast<const Protos::ImageMessage *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyMessageContentVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<MessageContent> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMessageContent(
        verifier,  values->Get(i), types->GetEnum<MessageContent>(i))) {
      return false;
    }
  }
  return true;
}

inline const Protos::MessageRoot *GetMessageRoot(const void *buf) {
  return ::flatbuffers::GetRoot<Protos::MessageRoot>(buf);
}

inline const Protos::MessageRoot *GetSizePrefixedMessageRoot(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Protos::MessageRoot>(buf);
}

inline bool VerifyMessageRootBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Protos::MessageRoot>(nullptr);
}

inline bool VerifySizePrefixedMessageRootBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Protos::MessageRoot>(nullptr);
}

inline void FinishMessageRootBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Protos::MessageRoot> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedMessageRootBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Protos::MessageRoot> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace Protos

#endif  // FLATBUFFERS_GENERATED_PROTO_PROTOS_H_
